
from mesa import Agent
import networkx as nx

# ---------------------------------------------------------------
class Infra(Agent):
    """Base class for all infrastructures"""

    # How many vehicles are in/on (or generated/removed by) this infrastructure
    vehicle_count = 0

    def __init__(self, unique_id, model, length=0,
                 name='Unknown', road_name='Unknown'):
        super().__init__(unique_id, model)
        self.length = length  # in meters
        self.name = name
        self.road_name = road_name

    def step(self):
        pass


# ---------------------------------------------------------------
class Bridge(Infra):
    condition = 'Unknown'


# ---------------------------------------------------------------

class Link(Infra):
    pass


# ---------------------------------------------------------------

class Sink(Infra):

    # indicate if a vehicle is removed
    vehicle_removed_toggle = False

    def remove(self, vehicle):
        # TODO: Collect vehicle data
        self.model.schedule.remove(vehicle)
        self.vehicle_count += 1
        self.vehicle_removed_toggle = not self.vehicle_removed_toggle
        print("SINK " + str(self.unique_id) + ' REMOVE ' + str(vehicle.unique_id))


# ---------------------------------------------------------------

class Source(Infra):
    """
    Class variable: how many trucks are generated by all sources
    Used as Truck ID
    """
    truck_counter = 0

    # indicate if a Truck is generated in this tick
    vehicle_generated_flag = False

    def generate_truck(self):
        try:
            agent = Vehicle('Truck' + str(Source.truck_counter), self.model, self)
            if agent:
                self.model.schedule.add(agent)
                Source.truck_counter += 1  # how many are generated by all sources
                self.vehicle_count += 1  # how many are generated by this source
                self.vehicle_generated_flag = True
                print("GENERATE " + str(agent.unique_id))
        except Exception as e:
            print("Oops!", e.__class__, "occurred in generate truck.")

    def step(self):
        if self.model.schedule.steps % 5 == 0:    #generate truck every 5 minutes 
            self.generate_truck()
        else:
            self.vehicle_generated_flag = False


# ---------------------------------------------------------------
class Vehicle(Agent):
    speed = 50 * 1000 / 60  # 50 km/h translated into meter per min
    step_time = 1   # ONE tick represents ONE minute !

    def __init__(self, unique_id, model, generated_by, location_offset=0):
        super().__init__(unique_id, model)
        self.generated_by = generated_by
        self.location = generated_by
        self.location_index = 0
        self.location_offset = location_offset
        self.pos = generated_by.pos   #current position is that of the source it is generated by.
        self.name = ''
        self.length = 1

        #to give unique paths to each vehicle. 
        #self.origin = generated_by.unique_id
        #self.destination= destination 
        self.vehicle_path = []
    
    def get_path(self, origin, destination):
        self.origin= origin
        self.destination = destination
        self.vehicle_path = nx.shortest_path(self.model.G, self.origin, self.destination)
        print('origin is', self.origin, 'of', self.unique_id, 'and destination', self.destination)
        #print('Vehicle path of ', self.unique_id, 'is', self.vehicle_path)


    def step(self):
        self.get_path(10000, 10010)
        self.drive()

    def drive_to_next(self, distance):
        self.location_index += 1
        #print(self.location_index,'self.location_index of vehicle', self.unique_id)
        next_id = self.vehicle_path[self.location_index]  
        #print('next id is', next_id)     
        # Access to protected member _agents
        next_infra = self.model.schedule._agents[next_id]
        #print('next infrastructure is', next_infra
        
        #next_id = self.model.path_ids[self.location_index]   #yilin

        if (type(next_infra) is Sink) or (self.location_index == len(self.vehicle_path)):
            self.location.vehicle_count -= 1
            self.location = next_infra
            self.location_offset = 0
            print(self, 'is going to be removed')
            self.location.remove(self)

            return
        

        if next_infra.length > distance:
            # stay on this object:
            self.location.vehicle_count -= 1
            self.location = next_infra
            self.location_offset = distance
            self.location.vehicle_count += 1
        else:
            # move to next object:
            self.drive_to_next(distance - next_infra.length)

    def drive(self):

        distance = self.speed * self.step_time
        distance_rest = self.location_offset + distance - self.location.length

        if distance_rest > 0:
            # go to the next object
            self.drive_to_next(distance_rest)

        else:
            # remain on the same object
            self.location_offset += distance

        print(self.unique_id + " " + str(self.location.unique_id) + '(' +
              str(self.location.vehicle_count) + ') ' + str(self.location_offset))

