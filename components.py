
from mesa import Agent
from enum import Enum
import random


# ---------------------------------------------------------------
class Infra(Agent):
    """Base class for all infrastructures"""

    # How many vehicles are in/on (or generated/removed by) this infrastructure
    vehicle_count = 0

    def __init__(self, unique_id, model, length=0,
                 name='Unknown', road_name='Unknown'):
        super().__init__(unique_id, model)
        self.length = length  # in meters
        self.name = name
        self.road_name = road_name

    def step(self):
        pass


# ---------------------------------------------------------------
class Bridge(Infra):
    condition = 'Unknown'

    def __init__(self, unique_id, model, length=0,
                 name='Unknown', road_name='Unknown'):
        super().__init__(unique_id, model, length, name, road_name)
        self.delay_time = random.randint(0, 10)

    def get_delay_time(self):
        return self.delay_time

    def __str__(self):
        return "Bridge" + str(self.unique_id)


# ---------------------------------------------------------------

class Link(Infra):

    def __str__(self):
        return "Link" + str(self.unique_id)


# ---------------------------------------------------------------

class Sink(Infra):

    # indicate if a vehicle is removed
    vehicle_removed_toggle = False

    def remove(self, vehicle):
        # TODO: Collect vehicle data
        self.model.schedule.remove(vehicle)
        self.vehicle_removed_toggle = not self.vehicle_removed_toggle
        print("Sink" + str(self.unique_id) + ' REMOVE ' + str(vehicle.unique_id))

    def __str__(self):
        return "Sink" + str(self.unique_id)


# ---------------------------------------------------------------

class Source(Infra):
    """
    Class variable: how many trucks are generated by all sources
    Used as Truck ID
    """
    truck_counter = 0

    # indicate if a Truck is generated in this tick
    vehicle_generated_flag = False

    def __str__(self):
        return "Source" + str(self.unique_id)

    def generate_truck(self):
        try:
            agent = Vehicle('Truck' + str(Source.truck_counter), self.model, self)
            if agent:
                self.model.schedule.add(agent)
                agent.set_path()
                Source.truck_counter += 1  # how many are generated by all sources
                self.vehicle_count += 1  # how many are generated by this source
                self.vehicle_generated_flag = True
                print("Source" + str(self.unique_id) + " GENERATE " + str(agent.unique_id))
        except Exception as e:
            print("Oops!", e.__class__, "occurred.")

    def step(self):
        if self.model.schedule.steps % 5 == 0:
            self.generate_truck()
        else:
            self.vehicle_generated_flag = False


# ---------------------------------------------------------------
class SourceSink(Source, Sink):

    def __str__(self):
        return "SourceSink" + str(self.unique_id)


# ---------------------------------------------------------------
class Vehicle(Agent):

    speed = 50 * 1000 / 60  # 50 km/h translated into meter per min
    step_time = 1   # One tick represents *1* minute !

    class State(Enum):
        DRIVE = 1
        WAIT = 2

    def __init__(self, unique_id, model, generated_by, location_offset=0, path_ids=None):
        super().__init__(unique_id, model)
        self.generated_by = generated_by
        self.location = generated_by
        self.location_offset = location_offset
        self.pos = generated_by.pos
        self.path_ids = path_ids
        # default values
        self.state = Vehicle.State.DRIVE
        self.location_index = 0
        self.waiting_time = 0
        self.waited_at = None

    def __str__(self):
        return "Vehicle" + str(self.unique_id)

    def set_path(self):
        self.path_ids = self.model.get_random_route(self.generated_by.unique_id)

    def step(self):

        if self.state == Vehicle.State.WAIT:
            self.waiting_time = max(self.waiting_time - 1, 0)
            if self.waiting_time == 0:
                self.waited_at = self.location
                self.state = Vehicle.State.DRIVE

        if self.state == Vehicle.State.DRIVE:
            self.drive()

        print(self.unique_id + " " + str(self.state) + '(' +
              str(self.waiting_time) + ') ' + str(self.location) + '(' +
              str(self.location.vehicle_count) + ') ' + str(self.location_offset))

    def drive(self):

        distance = Vehicle.speed * Vehicle.step_time
        distance_rest = self.location_offset + distance - self.location.length

        if distance_rest > 0:
            # go to the next object
            self.drive_to_next(distance_rest)

        else:
            # remain on the same object
            self.location_offset += distance

    def drive_to_next(self, distance):

        self.location_index += 1
        next_id = self.path_ids[self.location_index]
        # Access to protected member _agents
        next_infra = self.model.schedule._agents[next_id]

        if isinstance(next_infra, Sink):
            self.location.vehicle_count -= 1
            self.location = next_infra
            self.location_offset = 0
            self.location.vehicle_count += 1
            self.location.remove(self)
            return
        elif type(next_infra) is Bridge:
            self.waiting_time = next_infra.get_delay_time()
            if self.waiting_time > 0:
                self.location.vehicle_count -= 1
                self.location = next_infra
                self.location_offset = 0
                self.location.vehicle_count += 1
                self.state = Vehicle.State.WAIT
                return
            # Otherwise, continue moving

        if next_infra.length > distance:
            # stay on this object:
            self.location.vehicle_count -= 1
            self.location = next_infra
            self.location_offset = distance
            self.location.vehicle_count += 1
        else:
            # move to next object:
            self.drive_to_next(distance - next_infra.length)
